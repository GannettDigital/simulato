---
permalink: /test-generation/
title: "Test Generation"
toc: false
classes: wide
---

The automation of test generation is the real power behind Simulato as a testing solution. When thinking about traditional `Selenium` test scripts, most scripts are hand written, down a specific path through a system, to test a specific feature. This limits testing, often unintentionally, to creating tests that can be thought up by the person creating tests. By creating algorithms that generates tests for us, based on the components created to describe the system, we can remove that subjectivity to test generation. In addition, we can create different algorithms to solve different testing problems for a system using the same set of components that describe that system. This is the general theory behind model based testing, and why there is a lot of potential for creating high test coverage.  This document will describe the process that Simulato does when generating tests.

The heart of test generation is the search algorithm that is used to generate the tests. As of right now, Simulato uses only one simple search algorithm, `forward state space search`.  We have tailored the base concepts of `forward state space search` with custom heuristics to increase effeciency, finding ways for the algorithm to work faster for our specific problem. We provide a `coverage criteria` of performing every action modeled out by the system components, making sure that every action is perform at least once.  Deep knowledge of our algorithm, or any other algorithm implemented in the future, is not needed to understand the base concepts of what Simulato uses to generate tests.  To understand how tests are generated we need to talk about a few important concepts: `expected state`, `preconditions`, `effects`. This will give us the basis for how Simulato uses these three concepts to simulate the execution of test to generate test plans.

Whenever a component is added to the `expected state`, either through an entry component, the `effects` of an action, or as a `child` of component, we are telling Simulato what we expect the state of that component to be in at the given point of time inside the system. As we build out components to model our system under test, we continually modify, add to, and delete from the `expected state`. This describes how we expect the state to change as we perform `actions`.  When creating actions, only the `preconditions` and `effects` directly interact with state, while the `perform` is where we describe how to act upon the system, to lead to our expected `effects`.  

During planning, Simulato uses the **expected state** that we have specified to generate tests. Simulato does not have access to the system at this point, planning is entirely separate for the system under test. This means that the `perform` block is never run and only the `preconditions` and `effects` are looked at when generating tests. What this means is the **page state** is never accounted for, in any way, during planning. At all points in time, Simulato keeps track of the entire `expected state` that has been described by the combination of current components inside the `expected state`.  It then uses the `expected state`, to find `actions` that can be performed during that given `expected state`. Simulato looks at all current components inside the `expected state`, processing each component's `actions`, finding if their `preconditions` are met by the `expected state`. When an action has been found, who's `precondition` is met by the `expected state`, Simulato adds that onto the test plan. As every action has an `effects` section, Simulato will then process the `effects` block. The `effects` will describe what changes we expect that action to have on the state of the system. More specifically, that action will modify the `expected state` in some way to describe how we expect that action to change the system. Possible changes to the `expected state` include: new components with new actions can be added, components being removed, or the state of existing components change. Once the effects have been processed, including and and all modifications to the `expected state`, Simulato processes the information looking at the newly modified `expected state` to find actions whos `preconditions` are now met. As new `actions` are found with valid `preconditions`, the test script will continue to add actions, eventually forming a complete test when no new actions are found applicable to the `expected state`.

Simulato only has access to the expected state, and never the page state for planning. As such, never use part of a model who's `expected state` was filled in by `this.getFromPage()` as a precondition. During planning `this.getFromPage()` will ALWAYS return undefined. Which will be different than during test execution, where the page state can be accessed.
{: .notice--warning}

For Simulato to perform planning, it will need an `expected state` created to use as starting point to generate tests from. This is the main purpose of an `entry component`.  The `entry component` provides Simulato, all inside one component, the means to automatically add at a component on to the `expected state`.  At this point in the planning process, Simulato only has the `actions` provided by the `entry component` as available `actions` to choose from during test generation. Most entry components contain only one action, the action that enters us into the system under test. This action has no `preconditions`, so Simulato can always add it as the first action in a test. Once the `effects` of the action are processed, it will add new components, with new actions, to allow test generation to continue. Generation continues until the `coverage criteria` is met, that is, all `actions` described in the system are ran at least once. Once `coverage criteria` is met, planning will end, and a series of tests will have been created than we can now tell Simulato to run.